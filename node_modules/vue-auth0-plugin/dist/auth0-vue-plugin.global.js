/*!
  * vue-auth0-plugin v0.0.0-semantically-released
  */
var VueAuth0Plugin = (function (exports, vue, auth0SpaJs) {
    'use strict';

    const state = vue.reactive({
        loading: true,
        authenticated: false,
        getAuthenticatedAsPromise: () => new Promise((resolve) => {
            const unwatch = vue.watch(() => state.loading, async () => {
                if (!state.loading) {
                    unwatch();
                    resolve(state.authenticated);
                }
            });
        }),
        user: undefined,
        popupOpen: false,
        error: undefined,
    });
    const properties = vue.reactive({
        authenticated: false,
        getAuthenticatedAsPromise: state.getAuthenticatedAsPromise,
        loading: true,
        user: undefined,
        client: undefined,
        error: undefined,
        getIdTokenClaims,
        getTokenSilently,
        getTokenWithPopup,
        loginWithRedirect,
        loginWithPopup,
        logout,
    });
    Object.defineProperties(properties, {
        authenticated: {
            get() {
                return state.authenticated;
            },
            enumerable: false,
        },
        loading: {
            get() {
                return state.loading;
            },
            enumerable: false,
        },
        user: {
            get() {
                return state.user;
            },
            enumerable: false,
        },
        error: {
            get() {
                return state.error;
            },
            enumerable: false,
        },
    });
    let client;
    async function initialize(app, authClient, redirectUri) {
        client = authClient;
        // set client property to created Auth0Client instance
        properties.client = client;
        // If the user is returning to the app after authentication
        if ((redirectUri === undefined || window.location.href.split('?')[0] === redirectUri) &&
            (window.location.search.includes('state=') || window.location.search.includes('code='))) {
            let appState;
            try {
                // handle the redirect and retrieve tokens
                appState = (await client.handleRedirectCallback()).appState;
            }
            catch (e) {
                state.error = e;
            }
            finally {
                const targetUrl = appState && appState.targetUrl ? appState.targetUrl : '/';
                if (app.config.globalProperties.$router) {
                    app.config.globalProperties.$router.push(targetUrl);
                }
                else {
                    window.location.replace(targetUrl);
                }
            }
        }
        // Initialize our internal authentication state
        state.authenticated = await client.isAuthenticated();
        state.user = await client.getUser();
        state.loading = false;
    }
    var Plugin = {
        state,
        properties,
        initialize,
    };
    async function loginWithPopup(options, config) {
        state.popupOpen = true;
        state.loading = true;
        state.error = undefined;
        try {
            await client.loginWithPopup(options, config);
        }
        catch (e) {
            state.error = e;
        }
        finally {
            state.popupOpen = false;
            state.loading = false;
            state.user = await client.getUser();
            state.authenticated = await client.isAuthenticated();
        }
    }
    function loginWithRedirect(options) {
        return client.loginWithRedirect(options);
    }
    function getIdTokenClaims() {
        return client.getIdTokenClaims();
    }
    function getTokenSilently(options) {
        return client.getTokenSilently(options);
    }
    function getTokenWithPopup(options, config) {
        return client.getTokenWithPopup(options, config);
    }
    function logout(options) {
        return client.logout(options);
    }

    var AbstractAuthenticationGuard = async (to, from, autoLogin) => {
        // define verify method for later use
        const verify = async () => {
            if (Plugin.state.authenticated) {
                return true;
            }
            if (autoLogin) {
                await Plugin.properties.loginWithRedirect({ appState: { targetUrl: to.fullPath } });
            }
            return false;
        };
        // if not loading, verify request
        if (!Plugin.state.loading) {
            return verify();
        }
        // if loading, watch for loading property to change and then verify
        return new Promise((resolve) => {
            const unwatch = vue.watch(() => Plugin.state.loading, async () => {
                if (!Plugin.state.loading) {
                    unwatch();
                    resolve(verify());
                }
            });
        });
    };

    var AuthenticationGuardWithoutLoginRedirect = async (to, from) => {
        return AbstractAuthenticationGuard(to, from, false);
    };

    var AuthenticationGuardWithLoginRedirect = async (to, from) => {
        return AbstractAuthenticationGuard(to, from, true);
    };

    const vueAuthInjectionKey = 'auth';
    var index = {
        install(app, options) {
            app.provide(vueAuthInjectionKey, Plugin.properties);
            const client = new auth0SpaJs.Auth0Client(options);
            Plugin.initialize(app, client, options.authorizationParams?.redirect_uri);
        },
    };
    const injectAuth = () => vue.inject(vueAuthInjectionKey);
    const AuthenticationState = Plugin.state;
    const AuthenticationProperties = Plugin.properties;

    exports.AuthenticationGuard = AuthenticationGuardWithLoginRedirect;
    exports.AuthenticationGuardWithoutLoginRedirect = AuthenticationGuardWithoutLoginRedirect;
    exports.AuthenticationProperties = AuthenticationProperties;
    exports.AuthenticationState = AuthenticationState;
    exports["default"] = index;
    exports.injectAuth = injectAuth;
    exports.injectionKey = vueAuthInjectionKey;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({}, Vue, Auth0SpaJS);
